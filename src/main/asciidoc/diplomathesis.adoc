= Microservice Architecture and Distributed Systems
Ariel Simulevski <ariel@simulevski.at>
v0.1, 2019-03-24
:toc: macro
:math:
:media: prepress
:icons: font
:source-highlighter: rouge
:stem: latexmath

<<<

== Table of contents

<WIP: Asciidoctor really doesn't like PDF for some reason...>
//TODO: Fix toc
//:toc:

<<<

== Introduction

<WIP>

=== Distributed Systems

<WIP>

=== System Architectures

<WIP>

=== Structure of this Thesis



== Abstract

<WIP>

<<<

== Application Architectures

=== Monolithic Architectures

A monolithic architecture describes the structure of a system which houses the entire backend of a platform. Every part of the backend (persistence, business-logic, UI, etc...) is contained in this single program. <<monolith>>

One central paradigm of monoliths is layered architecture. Layered architecture describes a concept in which a program consists of multiple layers, each responsible for a specific thing with very limited interaction between said layers. <<layered-architecture>>

.Layered architecture pattern
[#img-monolith]
[caption="Figure 1: "]
image::../images/LayeredArchitecture.png[align=center]

==== Advantages

Although the concept of monolithic architecture is quite old, it still has decisive advantages over other architectures.

Due to the simplicity in architectural design, a monolith is very easy to develop, the layered architecture also allows for the application to be simple to test and the deployment of monolithic systems is also fairly straightforward: the binary of the program simply has to be copied to the target machine and then be executed. <<monolith>>

==== Drawbacks

That being said, due to some aspects of monolithic architecture, this architectural style has become unviable to most and even an antipattern to some. <<monolith-codingthearchitecture>>

Monolithic systems can become very complex to understand. Especially for new developers and fast growing projects, this is a big problem. Furthermore, an instance of a monolithic system cannot be updated without the instance shutting down. And due to the strongly-coupled nature of monoliths, unknown code dependencies might make the system crash because of a single change. <<monolith>> <<monolith-doomed>>

Even though, the drawbacks of monoliths outweigh the advantages, monolithic architecture is still widely used in smaller projects, legacy systems or projects which lack the necessary financial resources for a more advanced software architecture.

A typical monolithic architecture stack from Microsoft could look like so:

.Microsofts monolithic architecture stack
[#img-msstack]
[caption="Figure 2: "]
image::../images/MonolithicArchitectureMicrosoft.png[align=center, pdfwidth=8cm]

This is a fairly well known software stack from Microsoft. The described architecture uses ASP.NET as the system framework and Microsoft SQL Server as the database.

=== Microservice Architectures

Microservices have been the "architectural answer" to monoliths. Coined by Dr. Peter Rogers during a cloud computing conference, the term "micro web services" first described the idea of loosely coupled services which run independently and can each be maintained and developed individually. <<microservices-history>>

The term "microservice" was first used at a conference in Venice in 2011. In 2012 the architectural style gained more popularity. At a talk at a conference in Krakow (Micro services - Java, the Unix Way <<microservices-krakow>>), James Lewis presented his ideas on the topic. Later that year Adrian Cockcroft of Netflix described microservices as "fine-grained SOA" and helped establish a microservice architecture at Netflix, thus pioneering the architecture at scale. <<microservices-fowler>> <<microservices-medium>>

As Lewis described in 2012, microservices are "small with a single responsibility". This means that each microservice (or each application in the system) only does a single thing. According to Lewis, a microservice should be "Small enough to fit in [ones] head". The usecases of a single microservice are supposed to be so small, that one can think about all of them at the same time.


==== Advantages

Microservices were always seen as a successor to monoliths. <<microservices-history>> Therefore, they attempt to solve many of the problems that the monolithic architecture has. Due to each microservice being, relatively, small, the risk of a system becoming too complex for new developers to understand is kept to a minimum. The small, single responsibility nature of microservices allows for on-the-fly updating through CI/CD. Furthermore, microservices allow for language agnostic development. That means that one can use multiple programming languages and runtimes in one project to best suit the need of specific usecases/functions. <<monolith>> <<microservices-cicd>> <<microservices-dzone>>

==== Drawbacks

Of course, microservices are not the be-all and end-all of backend architecture and therefore do have some problems.

The added complexity of having to deal with distributed systems and inter-service communication might add difficulties to getting started with microservices. Due to having more applications in a single system, initial deployment may get difficult and very complex. And lastly, because of having more runtime instances, idle resource consumption with microservices is also significantly higher. <<monolith>>

[stem]
++++
c_{mon} = (\sum_{i=0}^l n_i)+m
++++

This formula describes the resource consumption of a monolith where stem:[n_i] is the resource consumption of a layer (at idle), stem:[l] is the number of layers and stem:[m] is the resource consumption of a runtime instance. As one can see, there is only one runtime instance, no matter how many layers there are.

[stem]
++++
c_{ms} = \sum_{i=0}^l (n_i+m_i)
++++

This formula describes the resource consumption of a system built on microservice architecture. Here, the cost of the runtime instance is added to every layer (or in that case service) one adds to the system.

The architecture for a system which builds upon a microservice architecture could look like this:

.Netflix microservice architecture stack
[#img-microservices]
[caption="Figure 2: "]
image::../images/MicroserviceArchitectureSpring.png[align=center]

This implementation of the microservice architecture utilizes the Netflix stack. The Netflix stack is a collection of libraries to make dealing with microservices easier. At the top of the architecture, there is the API gateway (the service that forwards requests to the services based on their route). Down below, there are the actual services with their corresponding databases (Couchbase in this particular example). Microservices do not always need to have their own database, but can also all have the same database.

=== Serverless Architectures

Serverless architecture was created out of the need for more efficient scalability out-of-the-box. <WIP>
//TODO

==== Advantages

==== Drawbacks

lock in
less control (websockets, etc...)

== Scaling Architectures in Distributed Systems

=== Monolithic

Since the monolithic architecture only scales through a replicated database, the cost function for a scaled monolith where stem:[s] is the number of machines the monolith is running on, stem:[c_{lb}] is the cost of the load-balancing forward and stem:[c_{net}] is the cost of the network communication, could look like so:

[stem]
++++
c_{scaled_{mon}} = s*((\sum_{i=0}^l n_i)+m) + b + nc
++++

Even though, scaling a monolith is quite efficient, due to the fact that one is not able to run scale individual monolith instances, one has to scale the entire monolith if one part of the domain model experiences a random hit. This means some parts of a monolith might not be used at all when scaling and scaling them is just a side-effect of wanting to scale one particular part of the system, which, in-turn, means unused resourced and higher cost.

=== Microservices

Microservice architecture, on the other hand, scales both through the replication of the database, as well as the replication of individual services (based on the load of these services).

This means that the runtime cost of a system utilizing microservice architecture could be described as such:

[stem]
++++
c_{scaled_{ms}} = \sum_{i=0}^s(\sum_{j = 0}^{ms_{total}} (ms_{ij}*(n_j+m_j))) + c_{lb} + c_{net}
++++

Where stem:[ms_total] is the number of individual microservices, stem:[ms_{ij}] is the number of instances of a specific microservice on a specific machine.

As one can deduct from the formulae above, scaling a monolith can be less expensive than scaling microservices if said microservices are all scaled at the same rate. This barely ever happens in a real production system, thus microservice architecture, with a varying scaling rate of each microservice, is often preferred over monolithic architecture.

=== Serverless

Scaling serverless systems looks very similar to microservice scaling. The major difference here is, of course, the unit of compute. This means that the base cost of serverless scaling is even higher (because serverless architecture requires more runtime instances to achieve the same result) than for a microservice architecture. Therefore, using serverless makes the most sense when the base cost of a system does not matter and only scaling performance is relevant.

=== Difficulties with scaling

As previously mentioned, both the monolithic architecture as well as microservice architecture do encounter some efficiency problems while scaling. The reason for that are the deployment containers one typically uses when dealing with monolith/microservice scaling (VMs and containers). When scaling VMs or containers, we always deal with threshold based scaling <<threshold-scaling>>. This means that we scale (add or remove) a deployment based on system resources used. Generally, we define both a lower threshold (~25% CPU load) and an upper threshold (~80% CPU load) for our system.

When every instance of our deployment reaches that upper threshold (with equal distributed load balancing, this should happen simultaneously), we add another VM/container to lower the load on other deployment instances to prevent system crashes or downtime.

The graph bellow shows a visual representation of the same computational space utilized in different manners. The white portion of each block symbolizes unused resources (overhead).

.Scaling overhead
[#img-scalingoverhead]
[.center]
[caption="Figure 3: "]
image::../images/scaling.png[align=center]

This also means, that one can never use more than the upper threshold defined for an operation, thus not utilizing the full potential of ones computational resources. The serverless architecture pattern solves that problem by shrinking down the unit of compute to the smallest possible size (functions), thus allowing more instances with a higher scaling threshold.

.AWS Lambda Response Time Distribution (P50-P95)
[#img-lambdaspeed]
[.center]
[caption="Figure 4: "]
image::../images/aws-lambda-p50-p95.png[align=center]

This graph shows the response time of an AWS Lambda function under load. As one can see, the median response (P50) remained stable during the entire test-run with even the 95th and 99th percentile showing close to no variance. <<serverless-scaling>>

== Scaling Across Datacenters

When scaling applications, one can reach the limit of their own data center quite fast. To overcome the limits of on-premise compute resources, people often rent compute resources in external data centers and clouds like the Google Cloud <<gcloud>>, Amazon AWS <<aws>> or Microsoft Azure <<azure>>.

This "computation-outsourcing" is often referred to as a "hybrid cloud" compared to having all compute resources on-premise ("private cloud") or having all compute resources in the cloud or external data centers ("public cloud" or "cloud native").

Although hybrid and public cloud systems seem to solve many problems with private cloud computing, like having to maintain less hardware yourself, being cheaper (to a certain point <<public-vs-private-cloud>>) and having SLA's in place which ensure uptime <<public-cloud-pro>>, there are some difficulties in hybrid/public clouds.

Things like integration complexity, network design or scale management can complicate a deployment or prevent a successful deployment altogether. <<hybrid-cloud-challenges>>

To overcome these problems many companies launched their own day-2 <<day-2>> management solutions like DC/OS <<dcos>> <<why-dcos>> or OpenShift <<openshift>>.

.DCOS Hybrid cloud
[#img-dcoshybrid]
[.center]
[caption="Figure 5: "]
image::../images/DCOSHybrid.jpg[align=center]

This image shows a DC/OS cluster which is deployed on a hybrid cloud. Some nodes (including the master nodes which act as the orchestrators <<orchestration-wiki>> for the system) are running on-premise, while others are running on different public clouds.

== Cloud architecture in Initiative Interchange

As we wanted low latency access for all of our users (including, but not limited to,  users in Canada , US, El Salvador, Mexico, Brazil, Argentina, Uruguay, Venezuela, Peru, Austria, Switzerland, Germany, France, Italy and Ukraine) and did not have enough money to launch a private cloud or enough knowledge to design our own public cloud infrastructure, we chose to deploy our application on AWS and utilize AWS infrastructure services (load balancing via AWS ELB <<aws-elb>>; networking via AWS VPC <<aws-vpc>>; global load balancing and DNS resolving via AWS Route 53 <<aws-r53>>; VMs on AWS EC2 <<aws-ec2>>) to our advantage.

Our initial approach was using DigitialOcea <<digitalocean>>  with DC/OS. This solution would have given us finer control over our application and VMs, and even though DigitalOcean was cheaper (8 CPUs, 32 GB RAM - DigitalOcean<<do-price>>: $0.238/hr; AWS<<aws-price>>: $0.384/hr), it was ultimately written off as it would have been more complicated to set up and did not offer the same enterprise grade features and locations as AWS did.

== Implementation of Social Networks

One of the best example of how social network architecture changed over the years is Facebook. Facebook started out with the very common PHP+MySQL stack all running on an Apache WebServer <<apache-server>>. This comes as no surprise as both PHP and MySQL are two of the most used technologies for web development. <<php-usage>> <<mysql-usage>>

Over the years, Facebook has adopted its tech stack to their higher demand but their underlying technology still is PHP and MySQL. Instead of using the Apache WebServer, Facebook developed a PHP runtime which converts PHP into bytecode for HHVM (**H**ip**H**op**V**irtual**M**achine), which then converts said bytecode into native x64 machine code. <<hhvm>>

Facebook has retired using MySQL as a relational database and is now using MySQL as a pure key-value store and Memcached <<memcached>> as a database cache to speed up read performance. <<fb-stack>>

Furthermore, Facebook developed their own storage/retrieval system called Haystack <<haystack-paper>> and is also using Hadoop <<hadoop>> and Hive as their big data storage/computation system. <<fb-stack>>

Facebooks architecture is one of the most impressive tech stacks currently in action. It has developed from a single $85/month server system <<fb-first-server>> to a giant platform with own data centers to fuel their operation. We tried to learn from Facebooks scaling experiences and design our architecture to have first class scaling support.

=== General Aspects on Implementing Social Networks

As previously mentioned, scaling is one of the most important challenges a social network faces. While a social network has to be fast and resource-optimized, one also has to keep cost in mind.

Since Initiative Interchange has members in 5 continents, we needed to ensure access speeds for our users.

.Client side load balacing
[#img-clientlb]
[.center]
[caption="Figure 6: "]
image::../images/client-side-lb.png[align=center]

Initially, we tried to do so by balancing the load from the client side with Netflix Ribbon (as you see in the picture above) but we changed our load balancing strategy to a DNS based one <<dns-lb>>, once we had to revise our backend architecture.

Another important aspect to keep in mind is security. Both user data, as well as servers have to be kept secure. With a privacy-by-design based approach in mind, we tried to carefully design our backend and security strategy to be in line with the EU-GDPR. In the end, we abandoned our initial security strategy and used an external one instead.

=== Initial Microservice Implementation

To solve all of the above mentioned problems, we wanted to chose a technology with which we were familiar and which was sufficiently mature and advanced to suit even our more unusual design choices (like client side load balancing and polyglot persistence).

Microservice seemed like the only feasible option since we were not aware of serverless technology and a monolithic architecture was not an option since we had to ensure efficient and cost-effective scalability of our platform.

==== System Architecture

.Initial Initiative Interchange backend architecture
[#img-i2springarch]
[.center]
[caption="Figure 7: "]
image::../images/i2-architecture-spring.png[align=center]

This architecture map shows the initial architecture design of our project. The underlying technology we are using is Spring Boot <<spring>>, a Java framework for enterprise-grade web applications. At the top of the map, one can see our API gateway and proxy: Netflix Zuul <<netflix-zuul>>. All services (including our authentication service) register to Zuul via Netflix Eureka <<netflix-eureka>>, a registry service for Spring Boot microservices.

Our authentication service (built with Spring Security) is in the layer bellow. Next to the authentication service, one can see all of our other services (also written in Spring Boot). All of our services are connected to a Logstash <<logstash>> instance which collects the logs of our services and sends them to an Elasticsearch <<elastic>> instance on a remote server so they can be analyzed and later visualized by Kibana <<kibana>>.

We have opted to use a polyglot persistence approach. Not only was one of our partners requirements was to display the closest relation between stem:[n] people, but we also found a polyglot persistence approach, where one database managed relations and another stores data, the most reliable for a highly scalable social network.

Say we have a group of people, A-J. We want to know the closest connection between A and D (in this case: A-> G -> D).

.Friends diagram
[caption="Figure 8: "]
[graphviz,frienddia,svg]
---------------------------------------------------------------------
digraph G {
    A -> B;
    A -> F;
    A -> G;
    F -> E;
    B -> C;
    B -> J;
    J -> G;
    B -> E;
    F -> I;
    I -> H;
    E -> D;
    E -> H;
    H -> D;
    C -> G;
    G -> D;
    C -> D;
}
---------------------------------------------------------------------

.Neo4j vs MySQL query time comparison
[#img-neo4jcomp]
[.center]
[caption="Figure 9: "]
image::../images/neo4j-vs-mysql.PNG[align=center]

The graph above shows the response time of both MySQL as well as Neo4j for such a use-case in a database with 1,000,000 users <<neo4j-mysql-friends>>. As one can see, the relational database did not even finish on a depth of 5.

We chose Couchbase <<couchbase>> because of its XDCR (**C**ross-**D**ata-**C**enter-**R**eplication), full-text-search and high-availability features.

==== Experience

Our experience with Spring Boot and the Netflix stack was very pleasant. There is a plenty of documentation, both from Pivotal <<spring-pivotal>> and external sources <<spring-baeldung>>. We did not encounter any instabilities and even more experimental aspects of our project, like polyglot persistence, were very stable.

==== Issues and Limitations

The major issues we encountered were not the fault of our technology stack. A couple of sprints into our project, one of our team-members had to leave our team. Due to that circumstance, we did not have enough human resources to complete the backend in time. Additionally, our project partner Initiative Interchange <<ii>>, a daughter organizations of Rotary International <<rotary>> and Unicef <<unicef>> partner, was not able to secure the necessary funding to deploy the project.

=== Moving to Serverless Implementation

Since we needed a new solution which would allow us to develop and deploy the backend with less human and financial resources than planned, we started research on alternatives to Spring Boot and, eventually, microservice architecture. In late December of 2018, we discovered serverless architecture and started assessing whether or not it would be a good fit for us and our project.

Most of our time savings came from not having to configure AWS Lambda. The scaling aspect of AWS Lambda <<aws-lambda>> is a built-in feature. Both service discovery and service gateway are managed by AWS and the AWS Route 53 requires very minimal configuration for the global load balancing.

Porting existing code to serverless was fairly trivial. Layered architecture still exists in a serverless environment, if a bit smaller. The major difference we had to get used to was the big focus on callback functions. The Spring Boot controllers were swapped with serverless hooks.

==== Spring Boot JPA Repository vs Node.js MySQL repository

.Repository in Java with Spring JPA
```java
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    Product findByName(String productName);
}
```

.Repository in JavaScript
```js
class ProductRepository{
    constructor(con){
        this.con = con;
    }

    findByName(name, callback){
        this.con.connect();

        this.con.query("SELECT * FROM `Product` WHERE `Name` = ?", [name],
        function (error, results, fields){
            if (error) callback(error,null);
            callback(null,results);
        });

        this.con.end();
    }
}
```

==== Spring Boot Controller vs Node.js AWS Lambda Hook

.Helloworld controller in Java with Spring
```java
@Controller
@RequestMapping("/")
public class HelloWorldController {

    @GetMapping
    @ReponseBody
    public String index() {
        return "Hello world!";
    }
}
```

.Helloworld hook in JavaScript with AWS Lambda
```js
exports.handler = function(event, context, callback) {
    callback(null, "Hello world!");
}
```

==== Modified System Architecture

.New Initiative Interchange backend architecture
[#img-i2awsarch]
[.center]
[caption="Figure 10: "]
image::../images/i2-architecture-aws.png[align=center]

The image above shows our new architecture map. Due to the fact that we are using a serverless approach, the architecture map is a very abstract version of our technology stack.

In the bottom-left corner, one can see our global load balancer and DNS web service, AWS Route 53. Here, we register all of our API endpoints and distribute requests based on location.

AWS Cognito (in the bottom-right corner) is responsible for the user management of our application. Initially, we wanted to write our own user management system, but we noticed quickly that using an external, well-tested solution would be both more secure and easier to adopt.

Above AWS Cognito, we have AWS API Gateway. While Route 53 manages requests on a global scale, API Gateway manages requests on a per-location basis. AWS API Gateway is responsible for sending every request to the correct controller, load balancing between internal controller instances (via AWS ELB), control CORS (**C**ross-**O**rigin-**R**esource-**S**haring) rules and manage our application staging.

Next to API Gateway, one can see the three main parts of our application, consisting of AWS Lambda, AWS RDS and AWS Neptune. These components all communicate via AWS VPC. AWS VPC also exposes AWS Lambda to the outside (although this is automatically routed by AWS). AWS Lambda is our serverless runtime, while AWS RDS and AWS Neptune are our two main databases. We kept our polyglot persistence approach from our initial architecture but had to switch out Couchbase with AWS RDS <<aws-rds>> and Neo4j with AWS Neptune <<aws-neptune>> for financial reasons. We will switch back too Couchbase and Neo4j as soon as the project gets more funding.

The yellow arrows bellow our main components symbolize the automatic scaling aspect of our application. AWS Lambda scales on a per-request basis while both AWS RDS and AWS Neptune scale by an EC2 scale policy <<aws-scaling>> (threshold based <<threshold-scaling>>).

=== Comparison of Microservices and Serverless

When working with serverless architecture in AWS Lambda, we encountered some major differences to microservice architecture in Java with Spring Boot.

The biggest of them being the language agnostic nature of the serverless architecture pattern. It is definitely possible to use multiple languages in microservice architecture, but generally, mixing languages within a service is frowned upon. Due to the fact that serverless functions are closed system (every function is deployed on its own), polyglotism in within the serverless pattern is not only possible, but also easier to develop and to maintain.

This is made possible by the modularity of serverless functions. A key difference to microservices which allows rapid development and deployment of serverless applications.

== Results and Learnings

<WIP>

== Conclusion

<WIP>

<<<
[bibliography]
== References

- [[[monolith,1]]] Introduction to Monolithic Architecture and MicroServices Architecture: https://medium.com/koderlabs/introduction-to-monolithic-architecture-and-microservices-architecture-b211a5955c63
- [[[layered-architecture,2]]] 1. Layered Architecture - Software Architecture Patterns [Book]: https://www.oreilly.com/library/view/software-architecture-patterns/9781491971437/ch01.html
- [[[monolith-codingthearchitecture,3]]] What is a Monolith? - Coding the Architecture: http://www.codingthearchitecture.com/2014/11/19/what_is_a_monolith.html
- [[[monolith-doomed,4]]] Are Monolithic Software Applications Doomed for Extinction? - Nortal: https://nortal.com/de/blog/are-monolithic-software-applications-doomed-for-extinction/
- [[[microservices-history,5]]] Microservices: What They Are and Why Use Them: https://blog.leanix.net/en/a-brief-history-of-microservices
- [[[microservices-krakow,6]]] 33rd Degree - Conference for Java Masters - Micro services - Java, the Unix Way: http://2012.33degree.org/talk/show/67; http://2012.33degree.org/pdf/JamesLewisMicroServices.pdf
- [[[microservices-fowler,7]]] Microservices: https://martinfowler.com/articles/microservices.html
- [[[microservices-medium,8]]] Talking microservices with the man who made Netflix’s cloud famous: https://medium.com/s-c-a-l-e/talking-microservices-with-the-man-who-made-netflix-s-cloud-famous-1032689afed3
- [[[microservices-cicd,9]]] Continuous Deployment and Monitoring of Microservices - DevOps.com: https://devops.com/continuous-deployment-monitoring-microservices/
- [[[microservices-dzone,10]]] - Monolithic vs Microservice Architecture - DZone Integration: https://dzone.com/articles/monolithic-vs-microservice-architecture
- [[[threshold-scaling, 11]]] M. Mohan Murthy, H. Sanjay and Jumnal Anand. Threshold Based Auto Scaling of Virtual Machines in Cloud Environment https://hal.inria.fr/hal-01403090/document
- [[[serverless-scaling, 12]]] Serverless at Scale: Serving StackOverflow-like Traffic - Binaris Blog: https://blog.binaris.com/serverless-at-scale/
- [[[gcloud,13]]] - Google Cloud including GCP & G Suite — Try Free  |  Google Cloud: https://cloud.google.com/
- [[[aws, 14]]] - Amazon Web Services (AWS) - Cloud Computing Services: https://aws.amazon.com/
- [[[azure,15]]] - Microsoft Azure Cloud Computing Platform & Services: https://azure.microsoft.com/en-us/
- [[[public-vs-private-cloud, 16]]] - Is there a point where a private cloud is cheaper than the public cloud? | Network World: https://www.networkworld.com/article/2825994/is-there-a-point-where-a-private-cloud-is-cheaper-than-the-public-cloud.html
- [[[public-cloud-pro, 17]]] 10 business benefits of moving to public cloud: https://www.clariontech.com/blog/10-business-benefits-of-moving-to-public-cloud
- [[[hybrid-cloud-challenges, 18]]] What Are The Major Challenges Of Adopting A Hybrid Cloud Approach? - MiCORE Solutions: https://micoresolutions.com/major-challenges-adopting-hybrid-cloud-approach/
- [[[day-2, 19]]] Defining Day-2 Operations - DZone Agile: https://dzone.com/articles/defining-day-2-operations
- [[[dcos, 20]]] The Definitive Platform for Modern Apps | DC/OS: https://dcos.io/
- [[[why-dcos, 21]]] Why DC/OS | DC/OS: https://dcos.io/why-dcos/
- [[[openshift, 22]]] OpenShift: Container Application Platform by Red Hat, Built on Docker and Kubernetes: https://www.openshift.com/
- [[[orchestration-wiki, 23]]] Orchestration (computing) - Wikipedia: https://en.wikipedia.org/wiki/Orchestration_(computing)
- [[[aws-elb, 24]]] Elastic Load Balancing – Cloud-Load Balancer: https://aws.amazon.com/elasticloadbalancing/
- [[[aws-vpc, 25]]] Amazon Virtual Private Cloud (VPC): https://aws.amazon.com/vpc/
- [[[aws-r53, 26]]] Amazon Route 53 - Amazon Web Services: https://aws.amazon.com/route53/
- [[[aws-ec2, 27]]] Amazon EC2: https://aws.amazon.com/ec2/
- [[[digitalocean, 28]]] DigitalOcean - Cloud Computing, Simplicity at Scale: https://www.digitalocean.com/
- [[[do-price, 29]]] Pricing on DigitalOcean - Cloud virtual machine & storage pricing: https://www.digitalocean.com/pricing/#Compute
- [[[aws-price, 30]]] EC2 Instance Pricing – Amazon Web Services (AWS): https://aws.amazon.com/ec2/pricing/on-demand/
- [[[apache-server, 31]]] Welcome! - The Apache HTTP Server Project: https://httpd.apache.org/
- [[[php-usage, 32]]] Usage Statistics and Market Share of Server-side Programming Languages for Websites, March 2019: https://w3techs.com/technologies/overview/programming_language/all
- [[[mysql-usage, 33]]] DB-Engines Ranking - popularity ranking of database management systems: https://db-engines.com/en/ranking
- [[[hhvm, 34]]] HHVM | HHVM: https://hhvm.com/
- [[[memcached, 35]]] memcached - a distributed memory object caching system: http://memcached.org/
- [[[fb-stack, 36]]] Exploring the Software Behind Facebook, the World's Largest Social Media Site - Pingdom Royal: https://royal.pingdom.com/the-software-behind-facebook/
- [[[haystack-paper, 37]]] D. Beaver, S. Kumar, H.C. Li, J. Sobel and P. Vajgel. Finding a needle in Haystack: Facebook’s photo storage https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Beaver.pdf
- [[[hadoop, 38]]] The Apache Hadoop project: https://hadoop.apache.org/
- [[[hive, 39]]] The Apache Hive project: https://hive.apache.org/
- [[[fb-first-server, 40]]] R. Empson. Facebook’s First Server Cost $85/Month, TechCrunch, 2012 https://techcrunch.com/2012/10/20/facebooks-first-server-cost-85month/
- [[[dns-lb, 41]]] Y.S. Hong, J.H. No and S.Y. Kim. DNS-based load balancing in distributed Web-server systems https://ieeexplore.ieee.org/abstract/document/1611743
- [[[spring, 42]]] Spring Boot: https://spring.io/projects/spring-boot
- [[[netflix-zuul, 43]]] Netflix/zuul: Zuul is a gateway service that provides dynamic routing, monitoring, resiliency, security, and more.: https://github.com/Netflix/zuul
- [[[netflix-eureka, 44]]] Netflix/eureka: AWS Service registry for resilient mid-tier load balancing and failover.: https://github.com/Netflix/eureka
- [[[logstash, 45]]] Logstash: Collect, Parse, Transform Logs | Elastic: https://www.elastic.co/products/logstash
- [[[elastic, 46]]] Elasticsearch: RESTful, Distributed Search & Analytics | Elastic: https://www.elastic.co/products/elasticsearch
- [[[kibana, 47]]] Kibana: Explore, Visualize, Discover Data | Elastic: https://www.elastic.co/products/kibana
- [[[neo4j-mysql-friends, 48]]] How much faster is a graph database, really? - Neo4j Graph Database Platform: https://neo4j.com/news/how-much-faster-is-a-graph-database-really/
- [[[couchbase, 49]]] NoSQL Engagement Database | Couchbase: https://www.couchbase.com/
- [[[spring-pivotal, 50]]] Guides: https://spring.io/guides
- [[[spring-baeldung, 51]]] Baeldung | Java, Spring and Web Development tutorials: https://www.baeldung.com/
- [[[ii,52]]] Initiative Interchange: https://www.initiative-interchange.org/
- [[[rotary, 53]]] Home | Rotary International: https://www.rotary.org/en
- [[[unicef, 54]]] Home page | UNICEF: https://www.unicef.org/
- [[[aws-lambda, 55]]] AWS Lambda – Serverless Compute - Amazon Web Services: https://aws.amazon.com/lambda/
- [[[aws-rds, 56]]] Amazon Relational Database Service (RDS) – AWS: https://aws.amazon.com/rds/
- [[[aws-neptune, 57]]] Amazon Neptune - Fast, Reliable Graph Database built for the cloud: https://aws.amazon.com/neptune/
- [[[aws-scaling, 58]]] Simple and Step Scaling Policies for Amazon EC2 Auto Scaling - Amazon EC2 Auto Scaling: https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-scaling-simple-step.html